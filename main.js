/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
IF YOU WANT TO VIEW THE SOURCE CODE, GO TO THE LINK BELOW
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  HttpServer: () => HttpServer,
  SLIDES_VIEW_TYPE: () => SLIDES_VIEW_TYPE,
  SlidesView: () => SlidesView,
  default: () => MarkdeepSlidesPlugin
});
module.exports = __toCommonJS(main_exports);
var http = __toESM(require("http"));
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var import_obsidian = require("obsidian");
var import_path = require("path");
var STATE_RECOVERY_SCRIPT = `
<script>
    window.addEventListener('DOMContentLoaded', () => {
        const savedHash = window.sessionStorage.getItem('markdeep_slide_hash');
        if (savedHash && !window.location.hash) {
            window.location.hash = savedHash;
        }
        window.sessionStorage.removeItem('markdeep_slide_hash'); // Clean up
    });
    window.addEventListener('beforeunload', () => {
        if (window.location.hash) {
            window.sessionStorage.setItem('markdeep_slide_hash', window.location.hash);
        }
    });
<\/script>
`;
var SLIDES_VIEW_TYPE = "markdeep-slides-view";
var SlidesView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return SLIDES_VIEW_TYPE;
  }
  getDisplayText() {
    return "Slide Preview";
  }
  getIcon() {
    return "presentation";
  }
  async setState(state, options) {
    this.url = state.url;
    this.htmlPath = state.htmlPath;
    await this.onOpen();
    return super.setState(state, options);
  }
  getState() {
    const state = super.getState();
    state.url = this.url;
    state.htmlPath = this.htmlPath;
    return state;
  }
  async onOpen() {
    this.contentEl.empty();
    this.contentEl.style.height = "100%";
    this.contentEl.style.display = "flex";
    this.contentEl.style.flexDirection = "column";
    if (!this.url) {
      this.contentEl.createEl("h2", { text: "No URL specified" });
      return;
    }
    const container = this.contentEl.createEl("div");
    container.style.flexGrow = "1";
    container.innerHTML = `<webview src="${this.url}" style="width:100%; height:100%; border:none;" webpreferences="allowRunningInsecureContent"></webview>`;
    const webview = container.find("webview");
    if (webview) {
      webview.addEventListener("dom-ready", () => {
      });
      webview.addEventListener("did-fail-load", (event) => {
        console.error("Failed to load slides:", event);
        this.contentEl.createEl("h2", { text: "Error Loading Slides" });
      });
    }
  }
  async onClose() {
    if (this.htmlPath) {
      this.plugin.removeSlideView(this.htmlPath);
    }
  }
};
var HttpServer = class {
  constructor(port, slidesPath) {
    this.server = null;
    this.port = port;
    this.slidesPath = slidesPath;
  }
  start() {
    return new Promise((resolve, reject) => {
      this.server = http.createServer(this.requestHandler.bind(this));
      this.server.listen(this.port, () => {
        console.log(`Server running at http://localhost:${this.port}/`);
        resolve();
      });
      this.server.on("error", (e) => {
        if (e.code === "EADDRINUSE") {
          reject(new Error(`Port ${this.port} is already in use.`));
        } else {
          reject(e);
        }
      });
    });
  }
  stop() {
    return new Promise((resolve, reject) => {
      if (this.server) {
        this.server.close((err) => {
          if (err)
            return reject(err);
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
  async requestHandler(req, res) {
    if (!req.url) {
      res.statusCode = 400;
      res.end("Bad Request: No URL");
      return;
    }
    const decodedUrl = decodeURIComponent(req.url);
    let filePath = path.join(this.slidesPath, decodedUrl);
    if (!filePath.startsWith(this.slidesPath)) {
      res.statusCode = 403;
      res.end("Forbidden");
      return;
    }
    fs.readFile(filePath, (err, data) => {
      if (err) {
        res.statusCode = err.code === "ENOENT" ? 404 : 500;
        res.end(err.code === "ENOENT" ? "File not found." : `Server error: ${err.message}`);
        return;
      }
      const ext = path.extname(filePath).toLowerCase();
      let contentType = "text/plain";
      switch (ext) {
        case ".html":
          contentType = "text/html";
          break;
        case ".css":
          contentType = "text/css";
          break;
        case ".js":
          contentType = "application/javascript";
          break;
        case ".json":
          contentType = "application/json";
          break;
        case ".png":
          contentType = "image/png";
          break;
        case ".jpg":
        case ".jpeg":
          contentType = "image/jpeg";
          break;
        case ".gif":
          contentType = "image/gif";
          break;
        case ".svg":
          contentType = "image/svg+xml";
          break;
      }
      res.setHeader("Content-Type", contentType);
      res.statusCode = 200;
      res.end(data);
    });
  }
  setSlidesPath(newPath) {
    this.slidesPath = newPath;
  }
};
var DEFAULT_SETTINGS = {
  slidesPath: "slides",
  port: 8765
};
var MarkdeepSlidesPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.slideViews = /* @__PURE__ */ new Map();
  }
  async onload() {
    await this.loadSettings();
    const vaultBasePath = this.app.vault.adapter.getBasePath();
    const absoluteSlidesPath = (0, import_path.join)(vaultBasePath, this.settings.slidesPath);
    this.httpServer = new HttpServer(this.settings.port, absoluteSlidesPath);
    try {
      await this.httpServer.start();
    } catch (e) {
      new import_obsidian.Notice(`Failed to start local server: ${e.message}`);
      console.error("Failed to start local server:", e);
    }
    this.registerEvent(this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian.TFile && this.slideViews.has(file.path)) {
        const view = this.slideViews.get(file.path);
        if (view) {
          const webview = view.contentEl.querySelector("webview");
          if (webview) {
            webview.reload();
          }
        }
      }
    }));
    let timeout;
    this.debouncedGenerateSlides = (editor, view) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        if (view.file)
          this.generateSlides(view.file, true);
      }, 3e3);
    };
    this.registerEvent(this.app.workspace.on("editor-change", this.debouncedGenerateSlides));
    this.addCommand({
      id: "generate-markdeep-slides",
      name: "Generate Markdeep Slides for current file",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile)
          this.generateSlides(activeFile, false);
        else
          new import_obsidian.Notice("No active file to generate slides from.");
      }
    });
    this.addCommand({
      id: "open-slides-in-browser",
      name: "Open Slides in Browser",
      callback: () => this.openSlidesInBrowser()
    });
    this.addCommand({
      id: "open-slides-in-external-browser",
      name: "Open Slides in External Browser",
      callback: () => this.openSlidesInExternalBrowser()
    });
    this.addSettingTab(new MarkdeepSlidesSettingTab(this.app, this));
    this.registerView(
      SLIDES_VIEW_TYPE,
      (leaf) => new SlidesView(leaf, this)
    );
    console.log("Markdeep Slides plugin loaded.");
  }
  onunload() {
    console.log("Markdeep Slides plugin unloaded.");
    if (this.httpServer)
      this.httpServer.stop();
    this.slideViews.clear();
  }
  removeSlideView(htmlPath) {
    this.slideViews.delete(htmlPath);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.httpServer) {
      const vaultBasePath = this.app.vault.adapter.getBasePath();
      const absoluteSlidesPath = (0, import_path.join)(vaultBasePath, this.settings.slidesPath);
      this.httpServer.setSlidesPath(absoluteSlidesPath);
    }
  }
  async openSlidesInExternalBrowser() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian.Notice("No active Markdown file.");
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter;
    if (!this.hasMdslidesTag(frontmatter)) {
      new import_obsidian.Notice('File does not have "mdslides" in its tags.');
      return;
    }
    const htmlPath = import_path.posix.join(this.settings.slidesPath, `${activeFile.basename}.html`);
    const htmlFile = this.app.vault.getAbstractFileByPath(htmlPath);
    if (!htmlFile)
      await this.generateSlides(activeFile, false);
    const slideUrl = `http://localhost:${this.settings.port}/${activeFile.basename}.html`;
    window.open(slideUrl, "_blank");
    new import_obsidian.Notice(`Opening slides in external browser...`);
  }
  async openSlidesInBrowser() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian.Notice("No active Markdown file.");
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter;
    if (!this.hasMdslidesTag(frontmatter)) {
      new import_obsidian.Notice('File does not have "mdslides" in its tags.');
      return;
    }
    const htmlPath = import_path.posix.join(this.settings.slidesPath, `${activeFile.basename}.html`);
    const htmlFile = this.app.vault.getAbstractFileByPath(htmlPath);
    if (!htmlFile)
      await this.generateSlides(activeFile, false);
    const slideUrl = `http://localhost:${this.settings.port}/${activeFile.basename}.html`;
    this.app.workspace.detachLeavesOfType(SLIDES_VIEW_TYPE);
    const leaf = this.app.workspace.getLeaf("split", "vertical");
    await leaf.setViewState({
      type: SLIDES_VIEW_TYPE,
      active: true,
      state: { url: slideUrl, htmlPath }
    });
    this.app.workspace.revealLeaf(leaf);
    const view = leaf.view;
    this.slideViews.set(htmlPath, view);
    new import_obsidian.Notice(`Opening slides in a new pane.`);
  }
  async generateSlides(file, isAuto) {
    if (!file || file.extension !== "md")
      return;
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!this.hasMdslidesTag(fileCache == null ? void 0 : fileCache.frontmatter)) {
      if (!isAuto)
        new import_obsidian.Notice('File does not have "mdslides" in its tags. Slides not generated.');
      return;
    }
    try {
      const fileContent = await this.app.vault.read(file);
      const frontmatterRegex = /^---\s*[\s\S]*?---\s*$/m;
      const content = fileContent.replace(frontmatterRegex, "");
      let htmlToProcess = content;
      const metaCharset = '<meta charset="utf-8">';
      if (htmlToProcess.includes("</head>")) {
        htmlToProcess = htmlToProcess.replace("</head>", `${metaCharset}
</head>`);
      } else {
        htmlToProcess = `${metaCharset}
${htmlToProcess}`;
      }
      const SCRIPT_TO_APPEND = `
<script src="markdeep-slides/slides-init.js"><\/script>`;
      const fullScript = `${STATE_RECOVERY_SCRIPT}
${SCRIPT_TO_APPEND}`;
      if (htmlToProcess.includes("</body>")) {
        htmlToProcess = htmlToProcess.replace("</body>", `${fullScript}
</body>`);
      } else {
        htmlToProcess = htmlToProcess + fullScript;
      }
      const finalHtml = htmlToProcess;
      const outputDir = this.settings.slidesPath;
      const outputPath = import_path.posix.join(outputDir, `${file.basename}.html`);
      try {
        await this.app.vault.createFolder(outputDir);
      } catch (e) {
      }
      const existingFile = this.app.vault.getAbstractFileByPath(outputPath);
      if (existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, finalHtml);
      } else {
        await this.app.vault.create(outputPath, finalHtml);
      }
      if (!isAuto)
        new import_obsidian.Notice(`Slides generated successfully at: ${outputPath}`);
      console.log(`Slides for ${file.basename} processed.`);
    } catch (error) {
      console.error("Error generating slides:", error);
      if (!isAuto)
        new import_obsidian.Notice("Failed to generate slides. See console for details.");
    }
  }
  hasMdslidesTag(frontmatter) {
    if (!(frontmatter == null ? void 0 : frontmatter.tags))
      return false;
    const tags = frontmatter.tags;
    if (typeof tags === "string") {
      return tags.split(",").map((t) => t.trim()).includes("mdslides");
    }
    return Array.isArray(tags) ? tags.includes("mdslides") : false;
  }
};
var MarkdeepSlidesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Markdeep Slides Settings" });
    new import_obsidian.Setting(containerEl).setName("Slides output path").setDesc("The vault path to save the generated HTML slide files.").addText((text) => text.setPlaceholder("e.g., slides").setValue(this.plugin.settings.slidesPath).onChange(async (value) => {
      this.plugin.settings.slidesPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Server port").setDesc("The local server port to use. Requires plugin reload to take effect.").addText((text) => text.setPlaceholder("e.g., 8765").setValue(this.plugin.settings.port.toString()).onChange(async (value) => {
      this.plugin.settings.port = value ? parseInt(value) : 8765;
      await this.plugin.saveSettings();
    }));
  }
};
