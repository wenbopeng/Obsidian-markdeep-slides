/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
IF YOU WANT TO VIEW THE SOURCE CODE, GO TO THE LINK BELOW
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  HttpServer: () => HttpServer,
  SLIDES_VIEW_TYPE: () => SLIDES_VIEW_TYPE,
  SlidesView: () => SlidesView,
  default: () => MarkdeepSlidesPlugin
});
module.exports = __toCommonJS(main_exports);
var http = __toESM(require("http"));
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var import_obsidian = require("obsidian");
var import_path = require("path");
var SLIDES_VIEW_TYPE = "markdeep-slides-view";
var SlidesView = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  getViewType() {
    return SLIDES_VIEW_TYPE;
  }
  getDisplayText() {
    return "Slide Preview";
  }
  getIcon() {
    return "presentation";
  }
  async setState(state, options) {
    this.url = state.url;
    await this.onOpen();
    return super.setState(state, options);
  }
  getState() {
    const state = super.getState();
    state.url = this.url;
    return state;
  }
  async onOpen() {
    this.contentEl.empty();
    this.contentEl.style.height = "100%";
    this.contentEl.style.display = "flex";
    this.contentEl.style.flexDirection = "column";
    this.contentEl.createEl("h2", { text: "Loading Slides..." });
    if (!this.url) {
      this.contentEl.empty();
      this.contentEl.createEl("h2", { text: "No URL specified" });
      return;
    }
    const container = this.contentEl.createEl("div");
    container.style.flexGrow = "1";
    container.innerHTML = `<webview src="${this.url}" style="width:100%; height:100%; border:none;"></webview>`;
    const webview = container.find("webview");
    if (webview) {
      webview.style.border = "none";
      webview.addEventListener("dom-ready", () => {
        this.contentEl.removeChild(this.contentEl.children[0]);
      });
      webview.addEventListener("did-fail-load", (event) => {
        console.error("Failed to load slides:", event);
        this.contentEl.empty();
        this.contentEl.createEl("h2", { text: "Error Loading Slides" });
        this.contentEl.createEl("p", { text: "Could not load the slide preview. Make sure the local server is running and the URL is correct." });
      });
    }
  }
  async onClose() {
  }
};
var SERVER_PORT = 8765;
var HttpServer = class {
  // The base path for your slides
  constructor(port, slidesPath) {
    this.server = null;
    this.port = port;
    this.slidesPath = slidesPath;
  }
  start() {
    return new Promise((resolve, reject) => {
      this.server = http.createServer(this.requestHandler.bind(this));
      this.server.listen(this.port, () => {
        console.log(`Server running at http://localhost:${this.port}/`);
        resolve();
      });
      this.server.on("error", (e) => {
        if (e.code === "EADDRINUSE") {
          console.error(`Port ${this.port} is already in use.`);
          reject(new Error(`Port ${this.port} is already in use.`));
        } else {
          console.error("Server error:", e.message);
          reject(e);
        }
      });
    });
  }
  stop() {
    return new Promise((resolve, reject) => {
      if (this.server) {
        this.server.close((err) => {
          if (err) {
            console.error("Error stopping server:", err.message);
            reject(err);
          } else {
            console.log("Server stopped.");
            resolve();
          }
        });
      } else {
        resolve();
      }
    });
  }
  async requestHandler(req, res) {
    if (!req.url) {
      res.statusCode = 400;
      res.end("Bad Request: No URL");
      return;
    }
    const decodedUrl = decodeURIComponent(req.url);
    console.log(`[Slides Server] Request URL: ${req.url}`);
    console.log(`[Slides Server] Decoded URL: ${decodedUrl}`);
    console.log(`[Slides Server] Slides Path: ${this.slidesPath}`);
    let filePath = path.join(this.slidesPath, decodedUrl);
    console.log(`[Slides Server] Full File Path: ${filePath}`);
    if (!filePath.startsWith(this.slidesPath)) {
      res.statusCode = 403;
      res.end("Forbidden");
      return;
    }
    fs.readFile(filePath, (err, data) => {
      if (err) {
        console.error(`[Slides Server] Error reading file: ${err.message}`);
        if (err.code === "ENOENT") {
          res.statusCode = 404;
          res.end("File not found.");
        } else {
          res.statusCode = 500;
          res.end(`Server error: ${err.message}`);
        }
        return;
      }
      const ext = path.extname(filePath).toLowerCase();
      let contentType = "text/plain";
      switch (ext) {
        case ".html":
          contentType = "text/html";
          break;
        case ".css":
          contentType = "text/css";
          break;
        case ".js":
          contentType = "application/javascript";
          break;
        case ".json":
          contentType = "application/json";
          break;
        case ".png":
          contentType = "image/png";
          break;
        case ".jpg":
        case ".jpeg":
          contentType = "image/jpeg";
          break;
        case ".gif":
          contentType = "image/gif";
          break;
        case ".svg":
          contentType = "image/svg+xml";
          break;
      }
      res.setHeader("Content-Type", contentType);
      res.statusCode = 200;
      res.end(data);
    });
  }
  // Method to update slidesPath if settings change
  setSlidesPath(newPath) {
    this.slidesPath = newPath;
  }
};
var DEFAULT_SETTINGS = {
  slidesPath: "slides"
};
var SCRIPT_TO_APPEND = `
<script src="markdeep-slides/slides-init.js"><\/script>
`;
var MarkdeepSlidesPlugin = class extends import_obsidian.Plugin {
  // Add this line
  async onload() {
    await this.loadSettings();
    const vaultBasePath = this.app.vault.adapter.getBasePath();
    const absoluteSlidesPath = (0, import_path.join)(vaultBasePath, this.settings.slidesPath);
    this.httpServer = new HttpServer(SERVER_PORT, absoluteSlidesPath);
    try {
      await this.httpServer.start();
    } catch (e) {
      new import_obsidian.Notice(`Failed to start local server: ${e.message}`);
      console.error("Failed to start local server:", e);
    }
    let timeout;
    this.debouncedGenerateSlides = (editor, view) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        if (view.file) {
          this.generateSlides(view.file, true);
        }
      }, 3e3);
    };
    this.registerEvent(
      this.app.workspace.on("editor-change", this.debouncedGenerateSlides)
    );
    this.addCommand({
      id: "generate-markdeep-slides",
      name: "Generate Markdeep Slides for current file",
      callback: () => {
        const activeFile = this.app.workspace.getActiveFile();
        if (activeFile) {
          this.generateSlides(activeFile, false);
        } else {
          new import_obsidian.Notice("No active file to generate slides from.");
        }
      }
    });
    this.addCommand({
      id: "open-slides-in-browser",
      name: "Open Slides in Browser",
      callback: () => this.openSlidesInBrowser()
    });
    this.addCommand({
      id: "open-slides-in-external-browser",
      name: "Open Slides in External Browser",
      callback: () => this.openSlidesInExternalBrowser()
    });
    this.addSettingTab(new MarkdeepSlidesSettingTab(this.app, this));
    this.registerView(
      SLIDES_VIEW_TYPE,
      (leaf) => new SlidesView(leaf)
      // URL is now passed via ViewState
    );
    console.log("Markdeep Slides plugin loaded.");
  }
  onunload() {
    console.log("Markdeep Slides plugin unloaded.");
    if (this.httpServer) {
      this.httpServer.stop();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.httpServer) {
      const vaultBasePath = this.app.vault.adapter.getBasePath();
      const absoluteSlidesPath = (0, import_path.join)(vaultBasePath, this.settings.slidesPath);
      this.httpServer.setSlidesPath(absoluteSlidesPath);
    }
  }
  async openSlidesInExternalBrowser() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian.Notice("No active Markdown file.");
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter;
    if (!this.hasMdslidesTag(frontmatter)) {
      new import_obsidian.Notice('File does not have "mdslides" in its tags.');
      return;
    }
    const htmlPath = (0, import_path.join)(this.settings.slidesPath, `${activeFile.basename}.html`);
    const htmlFile = this.app.vault.getAbstractFileByPath(htmlPath);
    if (!htmlFile) {
      await this.generateSlides(activeFile, false);
    }
    const slideUrl = `http://localhost:${SERVER_PORT}/${activeFile.basename}.html`;
    window.open(slideUrl, "_blank");
    new import_obsidian.Notice(`Opening slides in external browser...`);
  }
  async openSlidesInBrowser() {
    var _a;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || activeFile.extension !== "md") {
      new import_obsidian.Notice("No active Markdown file.");
      return;
    }
    const frontmatter = (_a = this.app.metadataCache.getFileCache(activeFile)) == null ? void 0 : _a.frontmatter;
    if (!this.hasMdslidesTag(frontmatter)) {
      new import_obsidian.Notice('File does not have "mdslides" in its tags.');
      return;
    }
    const htmlPath = (0, import_path.join)(this.settings.slidesPath, `${activeFile.basename}.html`);
    const htmlFile = this.app.vault.getAbstractFileByPath(htmlPath);
    if (!htmlFile) {
      await this.generateSlides(activeFile, false);
    }
    const slideUrl = `http://localhost:${SERVER_PORT}/${activeFile.basename}.html`;
    this.app.workspace.detachLeavesOfType(SLIDES_VIEW_TYPE);
    const leaf = this.app.workspace.getLeaf("split", "vertical");
    await leaf.setViewState({
      type: SLIDES_VIEW_TYPE,
      active: true,
      state: { url: slideUrl }
      // Pass the URL to the view state
    });
    this.app.workspace.revealLeaf(leaf);
    new import_obsidian.Notice(`Opening slides in a new pane.`);
  }
  // Removed getOpenCommand as it's no longer needed
  async generateSlides(file, isAuto) {
    if (!file || file.extension !== "md") {
      return;
    }
    const fileCache = this.app.metadataCache.getFileCache(file);
    const frontmatter = fileCache == null ? void 0 : fileCache.frontmatter;
    if (!this.hasMdslidesTag(frontmatter)) {
      if (!isAuto) {
        new import_obsidian.Notice('File does not have "mdslides" in its tags. Slides not generated.');
      }
      return;
    }
    try {
      const fileContent = await this.app.vault.read(file);
      const frontmatterRegex = /^---\s*[\s\S]*?---\s*/;
      const content = fileContent.replace(frontmatterRegex, "");
      let htmlToProcess = content;
      const metaCharset = '<meta charset="utf-8">';
      if (htmlToProcess.includes("</head>")) {
        htmlToProcess = htmlToProcess.replace("</head>", `${metaCharset}
</head>`);
      } else if (htmlToProcess.includes("<head>")) {
        htmlToProcess = htmlToProcess.replace("<head>", `<head>
${metaCharset}`);
      } else {
        htmlToProcess = `${metaCharset}
${htmlToProcess}`;
      }
      if (htmlToProcess.includes("</body>")) {
        htmlToProcess = htmlToProcess.replace("</body>", `${SCRIPT_TO_APPEND}
</body>`);
      } else if (htmlToProcess.includes("<html>")) {
        htmlToProcess = htmlToProcess.replace("</html>", `${SCRIPT_TO_APPEND}
</html>`);
      } else {
        htmlToProcess = htmlToProcess + SCRIPT_TO_APPEND;
      }
      const finalHtml = htmlToProcess;
      const outputDir = this.settings.slidesPath;
      const outputFileName = `${file.basename}.html`;
      const outputPath = (0, import_path.join)(outputDir, outputFileName);
      try {
        await this.app.vault.createFolder(outputDir);
      } catch (e) {
      }
      const existingFile = this.app.vault.getAbstractFileByPath(outputPath);
      if (existingFile && existingFile instanceof import_obsidian.TFile) {
        await this.app.vault.modify(existingFile, finalHtml);
      } else {
        await this.app.vault.create(outputPath, finalHtml);
      }
      if (!isAuto) {
        new import_obsidian.Notice(`Slides generated successfully at: ${outputPath}`);
      }
      console.log(`Slides for ${file.basename} processed.`);
    } catch (error) {
      console.error("Error generating slides:", error);
      if (!isAuto) {
        new import_obsidian.Notice("Failed to generate slides. See console for details.");
      }
    }
  }
  hasMdslidesTag(frontmatter) {
    if (!frontmatter || !frontmatter.tags) {
      return false;
    }
    const tags = frontmatter.tags;
    if (typeof tags === "string") {
      return tags.split(",").map((t) => t.trim()).includes("mdslides");
    }
    if (Array.isArray(tags)) {
      return tags.includes("mdslides");
    }
    return false;
  }
};
var MarkdeepSlidesSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Markdeep Slides Settings" });
    new import_obsidian.Setting(containerEl).setName("Slides output path").setDesc("The vault path to save the generated HTML slide files.").addText((text) => text.setPlaceholder("e.g., slides").setValue(this.plugin.settings.slidesPath).onChange(async (value) => {
      this.plugin.settings.slidesPath = value;
      await this.plugin.saveSettings();
    }));
  }
};
